#!/usr/bin/env node

/**
 * Generate Font List
 * 
 * This script scans the /public/fonts/ directory and generates a TypeScript file
 * containing the list of available fonts. The list is extracted from font file names
 * following the pattern: FontName-Weight.ttf
 * 
 * Usage: npx ts-node scripts/generate-fontlist.ts
 */

import fs from 'fs';
import path from 'path';

const FONTS_DIR = path.join(process.cwd(), 'public', 'fonts');
const OUTPUT_FILE = path.join(process.cwd(), 'frontend', 'lib', 'fonts.ts');

/**
 * Extract font family name from filename
 * Examples:
 * - "RobotoFlex.ttf" -> "Roboto Flex"
 * - "BarlowSemiCondensed-Bold.ttf" -> "Barlow Semi Condensed"
 */
function extractFontName(filename: string): string | null {
  // Remove .ttf extension
  const nameWithoutExt = filename.replace(/\.ttf$/, '');
  
  // Handle variable fonts (e.g., "Inter-VariableFont_opsz,wght.ttf" -> "Inter")
  if (nameWithoutExt.includes('-VariableFont')) {
    const baseName = nameWithoutExt.split('-VariableFont')[0];
    if (!baseName) return null;
    
    // Add spaces before capitals (CamelCase to spaces)
    const spaced = baseName.replace(/([A-Z])/g, ' $1').trim();
    return spaced;
  }
  
  // Remove weight suffix (e.g., -Bold, -Regular, -Italic, -Black)
  let baseName = nameWithoutExt
    .replace(/-(?:Bold|Regular|Italic|Black|Light|Thin|Medium|SemiBold|ExtraLight|ExtraBold)(?:Italic)?$/i, '');

  // If nothing was removed, it might be a variable font without weight (like RobotoFlex)
  // In that case, use the full name
  if (baseName === nameWithoutExt && !nameWithoutExt.includes('-')) {
    baseName = nameWithoutExt;
  } else if (baseName === nameWithoutExt) {
    // If nothing changed and it has a dash, skip it (unless it's a variable font, which we handled above)
    return null;
  }

  if (!baseName) {
    return null;
  }

  // Add spaces before capitals (CamelCase to spaces)
  // "BarlowSemiCondensed" -> "Barlow Semi Condensed"
  // "RobotoFlex" -> "Roboto Flex"
  const spaced = baseName.replace(/([A-Z])/g, ' $1').trim();
  
  return spaced;
}

/**
 * Generate the fonts.ts file
 */
function generateFontList() {
  try {
    // Read all .ttf files from fonts directory
    const files = fs.readdirSync(FONTS_DIR)
      .filter(file => file.endsWith('.ttf'));

    if (files.length === 0) {
      console.warn('‚ö†Ô∏è  No font files found in', FONTS_DIR);
      return;
    }

    // Extract unique font names
    const fontNames = new Set<string>();
    files.forEach(file => {
      const name = extractFontName(file);
      if (name) {
        fontNames.add(name);
      }
    });

    const sortedFonts = Array.from(fontNames).sort();

    if (sortedFonts.length === 0) {
      console.warn('‚ö†Ô∏è  Could not extract any font names from files');
      return;
    }

    // Generate TypeScript code
    const fontsArray = sortedFonts.map(f => `'${f}'`).join(', ');
    const fileContent = `/**
 * Generated font list
 * This file is auto-generated by scripts/generate-fontlist.ts
 * Do not edit manually!
 */

/**
 * Available fonts in the application
 */
export const PA_AVAILABLE_FONTS = [${fontsArray}] as const;

export type PAFontFamily = (typeof PA_AVAILABLE_FONTS)[number];
`;

    // Write to output file
    fs.writeFileSync(OUTPUT_FILE, fileContent, 'utf-8');
    console.log('‚úÖ Generated font list:', OUTPUT_FILE);
    console.log('üìù Available fonts:', sortedFonts.join(', '));
  } catch (error) {
    console.error('‚ùå Error generating font list:', error);
    process.exit(1);
  }
}

generateFontList();
