import fs from 'fs';
import path from 'path';

/**
 * Convert kebab-case and dot-notation to PascalCase
 * e.g., "checkmark-circle-fill" -> "CheckmarkCircleFill"
 * e.g., "square.and.arrow.down.on.square" -> "SquareAndArrowDownOnSquare"
 * Handles multi-letter abbreviations and numbers correctly
 */
function kebabToPascalCase(kebabStr: string): string {
  return kebabStr
    .split(/[-.]/)
    .filter(word => word.length > 0)
    .map(word => {
      // Handle special cases: numbers stay with preceding letter
      if (/^\d+$/.test(word)) return word;
      // Capitalize first letter, keep rest as-is
      return word.charAt(0).toUpperCase() + word.slice(1);
    })
    .join('');
}

/**
 * Extract SVG viewBox from file
 */
function extractViewBox(svgPath: string): string {
  const content = fs.readFileSync(svgPath, 'utf-8');
  const viewBoxMatch = content.match(/viewBox="([^"]*)"/);
  return viewBoxMatch ? viewBoxMatch[1] : '0 0 24 24';
}

/**
 * Extract SVG content from file, removing XML declaration and comments
 */
function extractSvgContent(svgPath: string): string {
  let content = fs.readFileSync(svgPath, 'utf-8');

  // Remove XML declaration
  content = content.replace(/<\?xml[^?]*\?>/g, '').trim();

  // Remove DOCTYPE
  content = content.replace(/<!DOCTYPE[^>]*>/g, '').trim();

  // Remove SVG comments
  content = content.replace(/<!--[\s\S]*?-->/g, '').trim();

  // Remove extra whitespace but preserve meaningful spaces
  content = content.replace(/>\s+</g, '><');

  // Replace hardcoded fill="white" or fill="black" with currentColor for theme support
  // This allows the icons to adapt to light/dark modes
  content = content.replace(/fill="(white|black|#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3})"/g, 'fill="currentColor"');

  // Extract the inner SVG content (everything inside <svg> tags)
  const svgMatch = content.match(/<svg[^>]*>([\s\S]*?)<\/svg>/);
  return svgMatch ? svgMatch[1].trim() : content;
}

/**
 * Generate icons-data.ts file with all SVG contents and viewBox data
 * Uses original Apple SF Symbol names (dot notation) as keys for consistency
 */
function generateIconsDataFile(iconsDir: string, iconNamesAndContent: Record<string, { content: string; viewBox: string }>): void {
  // Generate SVG content entries with original Apple symbol names as keys
  const svgEntries = Object.entries(iconNamesAndContent)
    .map(([pascalName, { content }]) => {
      const originalName = pascalCaseToDotNotation(pascalName);
      // Escape single quotes and newlines for TypeScript string literal
      const escapedContent = content.replace(/'/g, "\\'").replace(/\n/g, ' ').replace(/\s+/g, ' ');
      return `  '${originalName}': '${escapedContent}',`;
    })
    .join('\n');

  // Generate viewBox entries with original Apple symbol names as keys
  const viewBoxEntries = Object.entries(iconNamesAndContent)
    .map(([pascalName, { viewBox }]) => {
      const originalName = pascalCaseToDotNotation(pascalName);
      return `  '${originalName}': '${viewBox}',`;
    })
    .join('\n');

  const fileContent = `/**
 * SF Symbols Icons Data
 * 
 * This file is auto-generated by the generate-sf-symbols script.
 * It contains the SVG content and viewBox values for all SF Symbol icons.
 * 
 * DO NOT EDIT MANUALLY - Changes will be overwritten on next script run
 */

export const sfIconsData = {
${svgEntries}
} as const;

export const sfIconsViewBox = {
${viewBoxEntries}
} as const;

export type SFIconName = keyof typeof sfIconsData;
`;

  const filePath = path.join(iconsDir, 'icons-data.ts');
  fs.writeFileSync(filePath, fileContent);
  console.log(`\x1b[33m‚úÖ CREATED: icons-data.ts with ${Object.keys(iconNamesAndContent).length} icons\x1b[0m`);
}

/**
 * Convert PascalCase back to Apple Symbol name format (dot notation)
 * e.g., "ServerRack" -> "server.rack"
 * e.g., "CheckmarkCircleFill" -> "checkmark.circle.fill"
 */
function pascalCaseToDotNotation(pascalStr: string): string {
  return pascalStr
    .replace(/([A-Z])/g, (match, letter) => (match === pascalStr[0] ? match : `.${letter}`))
    .toLowerCase();
}

/**
 * Generate icon-map.ts file with symbol name to component name mapping
 * Maps Apple SF Symbol names (original dot notation) to their component export names
 */
function generateIconMapFile(iconsDir: string, iconNames: string[]): void {
  const sortedNames = Array.from(new Set(iconNames)).sort();

  const mapEntries = sortedNames
    .map(pascalName => {
      const originalName = pascalCaseToDotNotation(pascalName);
      return `  '${originalName}': 'SF${pascalName}',`;
    })
    .join('\n');

  const fileContent = `/**
 * SF Symbols Icon Map
 * 
 * This file is auto-generated by the generate-sf-symbols script.
 * Maps Apple SF Symbol names (original dot notation) to their component export names.
 * 
 * DO NOT EDIT MANUALLY - Changes will be overwritten on next script run
 * 
 * Usage:
 * import { sfIconMap } from './icon-map';
 * 
 * const componentName = sfIconMap['server.rack']; // Returns 'SFServerRack'
 */

export const sfIconMap = {
${mapEntries}
} as const;

export type SFIconMapKey = keyof typeof sfIconMap;
`;

  const filePath = path.join(iconsDir, 'icons-map.ts');
  fs.writeFileSync(filePath, fileContent);
  console.log(`\x1b[33m‚úÖ CREATED: icons-map.ts with ${sortedNames.length} mappings\x1b[0m`);
}

/**
 * Generate index.tsx file with all icon exports
 * Uses original Apple SF Symbol names (dot notation) to match icons-data keys
 */
function generateIndexFile(iconsDir: string, iconNames: string[]): void {
  const sortedNames = Array.from(new Set(iconNames)).sort();

  const exports = sortedNames
    .map(pascalName => {
      const originalName = pascalCaseToDotNotation(pascalName);
      return `export const SF${pascalName} = createSFIcon('${originalName}');`;
    })
    .join('\n');

  const fileContent = `/**
 * SF Symbols Icon Library - Index File
 * 
 * This file is auto-generated by the generate-sf-symbols script.
 * It exports all SF Symbol icon components for easy importing.
 * 
 * Usage:
 * import { SFCheckmark, SFCircle } from '../sf-symbols';
 */

import { createSFIcon } from './SFIcon';

${exports}
`;

  const filePath = path.join(iconsDir, 'index.tsx');
  fs.writeFileSync(filePath, fileContent);
  console.log(`üìù Generated: index.tsx with ${sortedNames.length} exports`);
}

/**
 * Main function to generate SF Icons from SVG files
 */
async function generateSFIcons() {
  const rawIconsDir = path.join(process.cwd(), 'frontend/components/sf-symbols/svgs');
  const iconsDir = path.join(process.cwd(), 'frontend/components/sf-symbols');

  // Check if raw icons directory exists
  if (!fs.existsSync(rawIconsDir)) {
    console.log(`üìÅ Creating directory: ${rawIconsDir}`);
    fs.mkdirSync(rawIconsDir, { recursive: true });
    console.log('‚ÑπÔ∏è  Please add your SVG files to this directory and run this script again.');
    return;
  }

  // Get all SVG files
  const svgFiles = fs.readdirSync(rawIconsDir).filter(file => file.endsWith('.svg'));

  if (svgFiles.length === 0) {
    console.log('‚ö†Ô∏è  No SVG files found in frontend/components/sf-symbols/svgs directory.');
    return;
  }

  console.log(`\nüîç Found ${svgFiles.length} SVG file(s)\n`);

  const iconNamesAndContent: Record<string, { content: string; viewBox: string }> = {};

  svgFiles.forEach(svgFile => {
    const iconName = kebabToPascalCase(svgFile.replace('.svg', ''));
    const svgPath = path.join(rawIconsDir, svgFile);

    try {
      const svgContent = extractSvgContent(svgPath);
      const viewBox = extractViewBox(svgPath);
      iconNamesAndContent[iconName] = { content: svgContent, viewBox };
      console.log(`\x1b[33m‚úÖ PROCESSED: ${svgFile} ‚Üí ${iconName}\x1b[0m`);
    } catch (error) {
      console.error(`‚ùå ERROR processing ${svgFile}:`, error instanceof Error ? error.message : error);
    }
  });

  // Generate files
  generateIconsDataFile(iconsDir, iconNamesAndContent);
  generateIndexFile(iconsDir, Object.keys(iconNamesAndContent));
  generateIconMapFile(iconsDir, Object.keys(iconNamesAndContent));

  console.log(`\nüìä Summary: ${Object.keys(iconNamesAndContent).length} icons processed\n`);
}

// Run the generator
generateSFIcons().catch(error => {
  console.error('‚ùå Error generating SF Icons:', error);
  process.exit(1);
});
